# 判别器判断目标说明

## 📋 判别器的输入和输出

### 判别器架构

判别器是一个**二分类器**，输入是**人脸特征向量**（512维），输出是**单个标量**（真实/生成概率）。

```python
输入: features [batch, 512]  # InsightFace提取的人脸特征
输出: prediction [batch, 1]   # 真实/生成概率
```

## 🎯 两个判别器的判断目标

### D_A（判别器A）：判断侧面特征

**判断目标**：区分**真实的侧面特征**和**生成的侧面特征**

#### 输入1：真实侧面特征
```python
side_features = batch['src']  # 来自数据集的真实侧面特征
pred_real_A = model.D_A(side_features)
# 期望输出：接近1（真实）
```

#### 输入2：生成侧面特征
```python
fake_side = model.G_BA(front_features, angles, keypoints_3d, pose)
# G_BA：从正面特征生成侧面特征
pred_fake_A = model.D_A(fake_side)
# 期望输出：接近0（生成）
```

**训练目标**：
- 真实侧面特征 → 判别器输出接近1（真实）
- 生成侧面特征 → 判别器输出接近0（生成）

---

### D_B（判别器B）：判断正面特征

**判断目标**：区分**真实的正面特征**和**生成的正面特征**

#### 输入1：真实正面特征
```python
front_features = batch['tgt']  # 来自数据集的真实正面特征
pred_real_B = model.D_B(front_features)
# 期望输出：接近1（真实）
```

#### 输入2：生成正面特征
```python
fake_front = model.G_AB(side_features, angles, keypoints_3d, pose)
# G_AB：从侧面特征生成正面特征
pred_fake_B = model.D_B(fake_front)
# 期望输出：接近0（生成）
```

**训练目标**：
- 真实正面特征 → 判别器输出接近1（真实）
- 生成正面特征 → 判别器输出接近0（生成）

## 📊 数据流图

```
数据集:
  side_features (真实侧面) ←→ front_features (真实正面)

判别器A (D_A) 训练:
  真实侧面: side_features → D_A → 输出接近1 ✓
  生成侧面: G_BA(front_features) → D_A → 输出接近0 ✓

判别器B (D_B) 训练:
  真实正面: front_features → D_B → 输出接近1 ✓
  生成正面: G_AB(side_features) → D_B → 输出接近0 ✓

生成器训练:
  G_AB: side_features → fake_front → D_B → 希望输出接近1（欺骗判别器）
  G_BA: front_features → fake_side → D_A → 希望输出接近1（欺骗判别器）
```

## 🔍 关键点

### 1. 判别器判断的是**特征向量**，不是图像

- **输入**：512维的人脸特征向量（由InsightFace提取）
- **不是**：原始图像、关键点、角度等

### 2. 两个判别器分别判断不同域的特征

- **D_A**：判断侧面特征域（Domain A）
- **D_B**：判断正面特征域（Domain B）

### 3. 生成的特征用于对抗训练

```python
# 生成器希望"欺骗"判别器
fake_front = G_AB(side_features, ...)  # 生成正面特征
pred_fake_B = D_B(fake_front)  # 判别器判断
# 生成器损失：希望 pred_fake_B 接近1（被判别为真实）
```

### 4. 判别器训练时使用`.detach()`

```python
# 训练判别器时，生成的特征需要detach
fake_side = G_BA(front_features, ...).detach()
pred_fake_A = D_A(fake_side)
# 这样不会更新生成器的梯度
```

## 📝 代码示例

### 判别器A训练

```python
# 真实侧面特征
pred_real_A = model.D_A(side_features)  # [batch, 1]
loss_D_A_real = adversarial_loss_fn(pred_real_A, target_is_real=True)
# 目标：pred_real_A 接近1

# 生成侧面特征
fake_side = model.G_BA(front_features, angles, ...).detach()
pred_fake_A = model.D_A(fake_side)  # [batch, 1]
loss_D_A_fake = adversarial_loss_fn(pred_fake_A, target_is_real=False)
# 目标：pred_fake_A 接近0

loss_D_A = (loss_D_A_real + loss_D_A_fake) * 0.5
```

### 判别器B训练

```python
# 真实正面特征
pred_real_B = model.D_B(front_features)  # [batch, 1]
loss_D_B_real = adversarial_loss_fn(pred_real_B, target_is_real=True)
# 目标：pred_real_B 接近1

# 生成正面特征
fake_front = model.G_AB(side_features, angles, ...).detach()
pred_fake_B = model.D_B(fake_front)  # [batch, 1]
loss_D_B_fake = adversarial_loss_fn(pred_fake_B, target_is_real=False)
# 目标：pred_fake_B 接近0

loss_D_B = (loss_D_B_real + loss_D_B_fake) * 0.5
```

### 生成器训练（对抗损失）

```python
# 生成器希望"欺骗"判别器
fake_front = model.G_AB(side_features, angles, ...)
pred_fake_B = model.D_B(fake_front)  # 不使用detach！
loss_adv_G_AB = adversarial_loss_fn(pred_fake_B, target_is_real=True)
# 目标：pred_fake_B 接近1（被判别为真实）

fake_side = model.G_BA(front_features, angles, ...)
pred_fake_A = model.D_A(fake_side)  # 不使用detach！
loss_adv_G_BA = adversarial_loss_fn(pred_fake_A, target_is_real=True)
# 目标：pred_fake_A 接近1（被判别为真实）
```

## 🎯 总结

**判别器判断的是什么？**

1. **D_A（判别器A）**：
   - 判断输入的**侧面特征**是真实的（来自数据集）还是生成的（由G_BA从正面生成）

2. **D_B（判别器B）**：
   - 判断输入的**正面特征**是真实的（来自数据集）还是生成的（由G_AB从侧面生成）

3. **输入类型**：
   - 512维的人脸特征向量（InsightFace提取）
   - 不是图像、关键点、角度等

4. **输出类型**：
   - 单个标量（真实/生成概率）
   - LSGAN：输出范围(-∞, +∞)，>0表示真实，<0表示生成
   - BCE：输出范围(0, 1)，>0.5表示真实，<0.5表示生成

5. **训练目标**：
   - 判别器：正确区分真实和生成的特征
   - 生成器：生成的特征能够"欺骗"判别器（被判别为真实）
